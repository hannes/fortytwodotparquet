#
# Autogenerated by Thrift Compiler (0.19.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class Type(object):
    """
    Types supported by Parquet.  These types are intended to be used in combination
    with the encodings to control the on disk storage format.
    For example INT16 is not included as a type since a good encoding of INT32
    would handle this.

    """
    BOOLEAN = 0
    INT32 = 1
    INT64 = 2
    INT96 = 3
    FLOAT = 4
    DOUBLE = 5
    BYTE_ARRAY = 6
    FIXED_LEN_BYTE_ARRAY = 7

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "INT32",
        2: "INT64",
        3: "INT96",
        4: "FLOAT",
        5: "DOUBLE",
        6: "BYTE_ARRAY",
        7: "FIXED_LEN_BYTE_ARRAY",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "INT32": 1,
        "INT64": 2,
        "INT96": 3,
        "FLOAT": 4,
        "DOUBLE": 5,
        "BYTE_ARRAY": 6,
        "FIXED_LEN_BYTE_ARRAY": 7,
    }


class ConvertedType(object):
    """
    DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet.
    ConvertedType is superseded by LogicalType.  This enum should not be extended.

    See LogicalTypes.md for conversion between ConvertedType and LogicalType.

    """
    UTF8 = 0
    MAP = 1
    MAP_KEY_VALUE = 2
    LIST = 3
    ENUM = 4
    DECIMAL = 5
    DATE = 6
    TIME_MILLIS = 7
    TIME_MICROS = 8
    TIMESTAMP_MILLIS = 9
    TIMESTAMP_MICROS = 10
    UINT_8 = 11
    UINT_16 = 12
    UINT_32 = 13
    UINT_64 = 14
    INT_8 = 15
    INT_16 = 16
    INT_32 = 17
    INT_64 = 18
    JSON = 19
    BSON = 20
    INTERVAL = 21

    _VALUES_TO_NAMES = {
        0: "UTF8",
        1: "MAP",
        2: "MAP_KEY_VALUE",
        3: "LIST",
        4: "ENUM",
        5: "DECIMAL",
        6: "DATE",
        7: "TIME_MILLIS",
        8: "TIME_MICROS",
        9: "TIMESTAMP_MILLIS",
        10: "TIMESTAMP_MICROS",
        11: "UINT_8",
        12: "UINT_16",
        13: "UINT_32",
        14: "UINT_64",
        15: "INT_8",
        16: "INT_16",
        17: "INT_32",
        18: "INT_64",
        19: "JSON",
        20: "BSON",
        21: "INTERVAL",
    }

    _NAMES_TO_VALUES = {
        "UTF8": 0,
        "MAP": 1,
        "MAP_KEY_VALUE": 2,
        "LIST": 3,
        "ENUM": 4,
        "DECIMAL": 5,
        "DATE": 6,
        "TIME_MILLIS": 7,
        "TIME_MICROS": 8,
        "TIMESTAMP_MILLIS": 9,
        "TIMESTAMP_MICROS": 10,
        "UINT_8": 11,
        "UINT_16": 12,
        "UINT_32": 13,
        "UINT_64": 14,
        "INT_8": 15,
        "INT_16": 16,
        "INT_32": 17,
        "INT_64": 18,
        "JSON": 19,
        "BSON": 20,
        "INTERVAL": 21,
    }


class FieldRepetitionType(object):
    """
    Representation of Schemas

    """
    REQUIRED = 0
    OPTIONAL = 1
    REPEATED = 2

    _VALUES_TO_NAMES = {
        0: "REQUIRED",
        1: "OPTIONAL",
        2: "REPEATED",
    }

    _NAMES_TO_VALUES = {
        "REQUIRED": 0,
        "OPTIONAL": 1,
        "REPEATED": 2,
    }


class Encoding(object):
    """
    Encodings supported by Parquet.  Not all encodings are valid for all types.  These
    enums are also used to specify the encoding of definition and repetition levels.
    See the accompanying doc for the details of the more complicated encodings.

    """
    PLAIN = 0
    PLAIN_DICTIONARY = 2
    RLE = 3
    BIT_PACKED = 4
    DELTA_BINARY_PACKED = 5
    DELTA_LENGTH_BYTE_ARRAY = 6
    DELTA_BYTE_ARRAY = 7
    RLE_DICTIONARY = 8
    BYTE_STREAM_SPLIT = 9

    _VALUES_TO_NAMES = {
        0: "PLAIN",
        2: "PLAIN_DICTIONARY",
        3: "RLE",
        4: "BIT_PACKED",
        5: "DELTA_BINARY_PACKED",
        6: "DELTA_LENGTH_BYTE_ARRAY",
        7: "DELTA_BYTE_ARRAY",
        8: "RLE_DICTIONARY",
        9: "BYTE_STREAM_SPLIT",
    }

    _NAMES_TO_VALUES = {
        "PLAIN": 0,
        "PLAIN_DICTIONARY": 2,
        "RLE": 3,
        "BIT_PACKED": 4,
        "DELTA_BINARY_PACKED": 5,
        "DELTA_LENGTH_BYTE_ARRAY": 6,
        "DELTA_BYTE_ARRAY": 7,
        "RLE_DICTIONARY": 8,
        "BYTE_STREAM_SPLIT": 9,
    }


class CompressionCodec(object):
    """
    Supported compression algorithms.

    Codecs added in format version X.Y can be read by readers based on X.Y and later.
    Codec support may vary between readers based on the format version and
    libraries available at runtime.

    See Compression.md for a detailed specification of these algorithms.

    """
    UNCOMPRESSED = 0
    SNAPPY = 1
    GZIP = 2
    LZO = 3
    BROTLI = 4
    LZ4 = 5
    ZSTD = 6
    LZ4_RAW = 7

    _VALUES_TO_NAMES = {
        0: "UNCOMPRESSED",
        1: "SNAPPY",
        2: "GZIP",
        3: "LZO",
        4: "BROTLI",
        5: "LZ4",
        6: "ZSTD",
        7: "LZ4_RAW",
    }

    _NAMES_TO_VALUES = {
        "UNCOMPRESSED": 0,
        "SNAPPY": 1,
        "GZIP": 2,
        "LZO": 3,
        "BROTLI": 4,
        "LZ4": 5,
        "ZSTD": 6,
        "LZ4_RAW": 7,
    }


class PageType(object):
    DATA_PAGE = 0
    INDEX_PAGE = 1
    DICTIONARY_PAGE = 2
    DATA_PAGE_V2 = 3

    _VALUES_TO_NAMES = {
        0: "DATA_PAGE",
        1: "INDEX_PAGE",
        2: "DICTIONARY_PAGE",
        3: "DATA_PAGE_V2",
    }

    _NAMES_TO_VALUES = {
        "DATA_PAGE": 0,
        "INDEX_PAGE": 1,
        "DICTIONARY_PAGE": 2,
        "DATA_PAGE_V2": 3,
    }


class BoundaryOrder(object):
    """
    Enum to annotate whether lists of min/max elements inside ColumnIndex
    are ordered and if so, in which direction.

    """
    UNORDERED = 0
    ASCENDING = 1
    DESCENDING = 2

    _VALUES_TO_NAMES = {
        0: "UNORDERED",
        1: "ASCENDING",
        2: "DESCENDING",
    }

    _NAMES_TO_VALUES = {
        "UNORDERED": 0,
        "ASCENDING": 1,
        "DESCENDING": 2,
    }


class SizeStatistics(object):
    """
    A structure for capturing metadata for estimating the unencoded,
    uncompressed size of data written. This is useful for readers to estimate
    how much memory is needed to reconstruct data in their memory model and for
    fine grained filter pushdown on nested structures (the histograms contained
    in this structure can help determine the number of nulls at a particular
    nesting level and maximum length of lists).

    Attributes:
     - unencoded_byte_array_data_bytes: The number of physical bytes stored for BYTE_ARRAY data values assuming
    no encoding. This is exclusive of the bytes needed to store the length of
    each byte array. In other words, this field is equivalent to the `(size
    of PLAIN-ENCODING the byte array values) - (4 bytes * number of values
    written)`. To determine unencoded sizes of other types readers can use
    schema information multiplied by the number of non-null and null values.
    The number of null/non-null values can be inferred from the histograms
    below.

    For example, if a column chunk is dictionary-encoded with dictionary
    ["a", "bc", "cde"], and a data page contains the indices [0, 0, 1, 2],
    then this value for that data page should be 7 (1 + 1 + 2 + 3).

    This field should only be set for types that use BYTE_ARRAY as their
    physical type.
     - repetition_level_histogram: When present, there is expected to be one element corresponding to each
    repetition (i.e. size=max repetition_level+1) where each element
    represents the number of times the repetition level was observed in the
    data.

    This field may be omitted if max_repetition_level is 0 without loss
    of information.

     - definition_level_histogram: Same as repetition_level_histogram except for definition levels.

    This field may be omitted if max_definition_level is 0 or 1 without
    loss of information.


    """


    def __init__(self, unencoded_byte_array_data_bytes=None, repetition_level_histogram=None, definition_level_histogram=None,):
        self.unencoded_byte_array_data_bytes = unencoded_byte_array_data_bytes
        self.repetition_level_histogram = repetition_level_histogram
        self.definition_level_histogram = definition_level_histogram

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.unencoded_byte_array_data_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.repetition_level_histogram = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI64()
                        self.repetition_level_histogram.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.definition_level_histogram = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI64()
                        self.definition_level_histogram.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SizeStatistics')
        if self.unencoded_byte_array_data_bytes is not None:
            oprot.writeFieldBegin('unencoded_byte_array_data_bytes', TType.I64, 1)
            oprot.writeI64(self.unencoded_byte_array_data_bytes)
            oprot.writeFieldEnd()
        if self.repetition_level_histogram is not None:
            oprot.writeFieldBegin('repetition_level_histogram', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.repetition_level_histogram))
            for iter12 in self.repetition_level_histogram:
                oprot.writeI64(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.definition_level_histogram is not None:
            oprot.writeFieldBegin('definition_level_histogram', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.definition_level_histogram))
            for iter13 in self.definition_level_histogram:
                oprot.writeI64(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Statistics(object):
    """
    Statistics per row group and per page
    All fields are optional.

    Attributes:
     - max: DEPRECATED: min and max value of the column. Use min_value and max_value.

    Values are encoded using PLAIN encoding, except that variable-length byte
    arrays do not include a length prefix.

    These fields encode min and max values determined by signed comparison
    only. New files should use the correct order for a column's logical type
    and store the values in the min_value and max_value fields.

    To support older readers, these may be set when the column order is
    signed.
     - min
     - null_count: count of null value in the column
     - distinct_count: count of distinct values occurring
     - max_value: Lower and upper bound values for the column, determined by its ColumnOrder.

    These may be the actual minimum and maximum values found on a page or column
    chunk, but can also be (more compact) values that do not exist on a page or
    column chunk. For example, instead of storing "Blart Versenwald III", a writer
    may set min_value="B", max_value="C". Such more compact values must still be
    valid values within the column's logical type.

    Values are encoded using PLAIN encoding, except that variable-length byte
    arrays do not include a length prefix.
     - min_value
     - is_max_value_exact: If true, max_value is the actual maximum value for a column
     - is_min_value_exact: If true, min_value is the actual minimum value for a column

    """


    def __init__(self, max=None, min=None, null_count=None, distinct_count=None, max_value=None, min_value=None, is_max_value_exact=None, is_min_value_exact=None,):
        self.max = max
        self.min = min
        self.null_count = null_count
        self.distinct_count = distinct_count
        self.max_value = max_value
        self.min_value = min_value
        self.is_max_value_exact = is_max_value_exact
        self.is_min_value_exact = is_min_value_exact

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.max = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.min = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.null_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.distinct_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.max_value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.min_value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_max_value_exact = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.is_min_value_exact = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Statistics')
        if self.max is not None:
            oprot.writeFieldBegin('max', TType.STRING, 1)
            oprot.writeBinary(self.max)
            oprot.writeFieldEnd()
        if self.min is not None:
            oprot.writeFieldBegin('min', TType.STRING, 2)
            oprot.writeBinary(self.min)
            oprot.writeFieldEnd()
        if self.null_count is not None:
            oprot.writeFieldBegin('null_count', TType.I64, 3)
            oprot.writeI64(self.null_count)
            oprot.writeFieldEnd()
        if self.distinct_count is not None:
            oprot.writeFieldBegin('distinct_count', TType.I64, 4)
            oprot.writeI64(self.distinct_count)
            oprot.writeFieldEnd()
        if self.max_value is not None:
            oprot.writeFieldBegin('max_value', TType.STRING, 5)
            oprot.writeBinary(self.max_value)
            oprot.writeFieldEnd()
        if self.min_value is not None:
            oprot.writeFieldBegin('min_value', TType.STRING, 6)
            oprot.writeBinary(self.min_value)
            oprot.writeFieldEnd()
        if self.is_max_value_exact is not None:
            oprot.writeFieldBegin('is_max_value_exact', TType.BOOL, 7)
            oprot.writeBool(self.is_max_value_exact)
            oprot.writeFieldEnd()
        if self.is_min_value_exact is not None:
            oprot.writeFieldBegin('is_min_value_exact', TType.BOOL, 8)
            oprot.writeBool(self.is_min_value_exact)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StringType(object):
    """
    Empty structs to use as logical type annotations

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StringType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UUIDType(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UUIDType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MapType(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MapType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ListType(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ListType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EnumType(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EnumType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DateType(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DateType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Float16Type(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Float16Type')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NullType(object):
    """
    Logical type to annotate a column that is always null.

    Sometimes when discovering the schema of existing data, values are always
    null and the physical type can't be determined. This annotation signals
    the case where the physical type was guessed from all null values.

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NullType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DecimalType(object):
    """
    Decimal logical type annotation

    Scale must be zero or a positive integer less than or equal to the precision.
    Precision must be a non-zero positive integer.

    To maintain forward-compatibility in v1, implementations using this logical
    type must also set scale and precision on the annotated SchemaElement.

    Allowed for physical types: INT32, INT64, FIXED, and BINARY

    Attributes:
     - scale
     - precision

    """


    def __init__(self, scale=None, precision=None,):
        self.scale = scale
        self.precision = precision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.scale = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.precision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DecimalType')
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.I32, 1)
            oprot.writeI32(self.scale)
            oprot.writeFieldEnd()
        if self.precision is not None:
            oprot.writeFieldBegin('precision', TType.I32, 2)
            oprot.writeI32(self.precision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.scale is None:
            raise TProtocolException(message='Required field scale is unset!')
        if self.precision is None:
            raise TProtocolException(message='Required field precision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MilliSeconds(object):
    """
    Time units for logical types

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MilliSeconds')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MicroSeconds(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MicroSeconds')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NanoSeconds(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NanoSeconds')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimeUnit(object):
    """
    Attributes:
     - MILLIS
     - MICROS
     - NANOS

    """


    def __init__(self, MILLIS=None, MICROS=None, NANOS=None,):
        self.MILLIS = MILLIS
        self.MICROS = MICROS
        self.NANOS = NANOS

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.MILLIS = MilliSeconds()
                    self.MILLIS.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.MICROS = MicroSeconds()
                    self.MICROS.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.NANOS = NanoSeconds()
                    self.NANOS.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimeUnit')
        if self.MILLIS is not None:
            oprot.writeFieldBegin('MILLIS', TType.STRUCT, 1)
            self.MILLIS.write(oprot)
            oprot.writeFieldEnd()
        if self.MICROS is not None:
            oprot.writeFieldBegin('MICROS', TType.STRUCT, 2)
            self.MICROS.write(oprot)
            oprot.writeFieldEnd()
        if self.NANOS is not None:
            oprot.writeFieldBegin('NANOS', TType.STRUCT, 3)
            self.NANOS.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimestampType(object):
    """
    Timestamp logical type annotation

    Allowed for physical types: INT64

    Attributes:
     - isAdjustedToUTC
     - unit

    """


    def __init__(self, isAdjustedToUTC=None, unit=None,):
        self.isAdjustedToUTC = isAdjustedToUTC
        self.unit = unit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isAdjustedToUTC = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.unit = TimeUnit()
                    self.unit.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimestampType')
        if self.isAdjustedToUTC is not None:
            oprot.writeFieldBegin('isAdjustedToUTC', TType.BOOL, 1)
            oprot.writeBool(self.isAdjustedToUTC)
            oprot.writeFieldEnd()
        if self.unit is not None:
            oprot.writeFieldBegin('unit', TType.STRUCT, 2)
            self.unit.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.isAdjustedToUTC is None:
            raise TProtocolException(message='Required field isAdjustedToUTC is unset!')
        if self.unit is None:
            raise TProtocolException(message='Required field unit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TimeType(object):
    """
    Time logical type annotation

    Allowed for physical types: INT32 (millis), INT64 (micros, nanos)

    Attributes:
     - isAdjustedToUTC
     - unit

    """


    def __init__(self, isAdjustedToUTC=None, unit=None,):
        self.isAdjustedToUTC = isAdjustedToUTC
        self.unit = unit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isAdjustedToUTC = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.unit = TimeUnit()
                    self.unit.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TimeType')
        if self.isAdjustedToUTC is not None:
            oprot.writeFieldBegin('isAdjustedToUTC', TType.BOOL, 1)
            oprot.writeBool(self.isAdjustedToUTC)
            oprot.writeFieldEnd()
        if self.unit is not None:
            oprot.writeFieldBegin('unit', TType.STRUCT, 2)
            self.unit.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.isAdjustedToUTC is None:
            raise TProtocolException(message='Required field isAdjustedToUTC is unset!')
        if self.unit is None:
            raise TProtocolException(message='Required field unit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IntType(object):
    """
    Integer logical type annotation

    bitWidth must be 8, 16, 32, or 64.

    Allowed for physical types: INT32, INT64

    Attributes:
     - bitWidth
     - isSigned

    """


    def __init__(self, bitWidth=None, isSigned=None,):
        self.bitWidth = bitWidth
        self.isSigned = isSigned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.bitWidth = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isSigned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IntType')
        if self.bitWidth is not None:
            oprot.writeFieldBegin('bitWidth', TType.BYTE, 1)
            oprot.writeByte(self.bitWidth)
            oprot.writeFieldEnd()
        if self.isSigned is not None:
            oprot.writeFieldBegin('isSigned', TType.BOOL, 2)
            oprot.writeBool(self.isSigned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.bitWidth is None:
            raise TProtocolException(message='Required field bitWidth is unset!')
        if self.isSigned is None:
            raise TProtocolException(message='Required field isSigned is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JsonType(object):
    """
    Embedded JSON logical type annotation

    Allowed for physical types: BINARY

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JsonType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BsonType(object):
    """
    Embedded BSON logical type annotation

    Allowed for physical types: BINARY

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BsonType')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LogicalType(object):
    """
    LogicalType annotations to replace ConvertedType.

    To maintain compatibility, implementations using LogicalType for a
    SchemaElement must also set the corresponding ConvertedType (if any)
    from the following table.

    Attributes:
     - STRING
     - MAP
     - LIST
     - ENUM
     - DECIMAL
     - DATE
     - TIME
     - TIMESTAMP
     - INTEGER
     - UNKNOWN
     - JSON
     - BSON
     - UUID
     - FLOAT16

    """


    def __init__(self, STRING=None, MAP=None, LIST=None, ENUM=None, DECIMAL=None, DATE=None, TIME=None, TIMESTAMP=None, INTEGER=None, UNKNOWN=None, JSON=None, BSON=None, UUID=None, FLOAT16=None,):
        self.STRING = STRING
        self.MAP = MAP
        self.LIST = LIST
        self.ENUM = ENUM
        self.DECIMAL = DECIMAL
        self.DATE = DATE
        self.TIME = TIME
        self.TIMESTAMP = TIMESTAMP
        self.INTEGER = INTEGER
        self.UNKNOWN = UNKNOWN
        self.JSON = JSON
        self.BSON = BSON
        self.UUID = UUID
        self.FLOAT16 = FLOAT16

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.STRING = StringType()
                    self.STRING.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.MAP = MapType()
                    self.MAP.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.LIST = ListType()
                    self.LIST.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ENUM = EnumType()
                    self.ENUM.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.DECIMAL = DecimalType()
                    self.DECIMAL.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.DATE = DateType()
                    self.DATE.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.TIME = TimeType()
                    self.TIME.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.TIMESTAMP = TimestampType()
                    self.TIMESTAMP.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.INTEGER = IntType()
                    self.INTEGER.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.UNKNOWN = NullType()
                    self.UNKNOWN.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.JSON = JsonType()
                    self.JSON.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.BSON = BsonType()
                    self.BSON.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.UUID = UUIDType()
                    self.UUID.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.FLOAT16 = Float16Type()
                    self.FLOAT16.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LogicalType')
        if self.STRING is not None:
            oprot.writeFieldBegin('STRING', TType.STRUCT, 1)
            self.STRING.write(oprot)
            oprot.writeFieldEnd()
        if self.MAP is not None:
            oprot.writeFieldBegin('MAP', TType.STRUCT, 2)
            self.MAP.write(oprot)
            oprot.writeFieldEnd()
        if self.LIST is not None:
            oprot.writeFieldBegin('LIST', TType.STRUCT, 3)
            self.LIST.write(oprot)
            oprot.writeFieldEnd()
        if self.ENUM is not None:
            oprot.writeFieldBegin('ENUM', TType.STRUCT, 4)
            self.ENUM.write(oprot)
            oprot.writeFieldEnd()
        if self.DECIMAL is not None:
            oprot.writeFieldBegin('DECIMAL', TType.STRUCT, 5)
            self.DECIMAL.write(oprot)
            oprot.writeFieldEnd()
        if self.DATE is not None:
            oprot.writeFieldBegin('DATE', TType.STRUCT, 6)
            self.DATE.write(oprot)
            oprot.writeFieldEnd()
        if self.TIME is not None:
            oprot.writeFieldBegin('TIME', TType.STRUCT, 7)
            self.TIME.write(oprot)
            oprot.writeFieldEnd()
        if self.TIMESTAMP is not None:
            oprot.writeFieldBegin('TIMESTAMP', TType.STRUCT, 8)
            self.TIMESTAMP.write(oprot)
            oprot.writeFieldEnd()
        if self.INTEGER is not None:
            oprot.writeFieldBegin('INTEGER', TType.STRUCT, 10)
            self.INTEGER.write(oprot)
            oprot.writeFieldEnd()
        if self.UNKNOWN is not None:
            oprot.writeFieldBegin('UNKNOWN', TType.STRUCT, 11)
            self.UNKNOWN.write(oprot)
            oprot.writeFieldEnd()
        if self.JSON is not None:
            oprot.writeFieldBegin('JSON', TType.STRUCT, 12)
            self.JSON.write(oprot)
            oprot.writeFieldEnd()
        if self.BSON is not None:
            oprot.writeFieldBegin('BSON', TType.STRUCT, 13)
            self.BSON.write(oprot)
            oprot.writeFieldEnd()
        if self.UUID is not None:
            oprot.writeFieldBegin('UUID', TType.STRUCT, 14)
            self.UUID.write(oprot)
            oprot.writeFieldEnd()
        if self.FLOAT16 is not None:
            oprot.writeFieldBegin('FLOAT16', TType.STRUCT, 15)
            self.FLOAT16.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SchemaElement(object):
    """
    Represents a element inside a schema definition.
     - if it is a group (inner node) then type is undefined and num_children is defined
     - if it is a primitive type (leaf) then type is defined and num_children is undefined
    the nodes are listed in depth first traversal order.

    Attributes:
     - type: Data type for this field. Not set if the current element is a non-leaf node
     - type_length: If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the values.
    Otherwise, if specified, this is the maximum bit length to store any of the values.
    (e.g. a low cardinality INT col could have this set to 3).  Note that this is
    in the schema, and therefore fixed for the entire file.
     - repetition_type: repetition of the field. The root of the schema does not have a repetition_type.
    All other nodes must have one
     - name: Name of the field in the schema
     - num_children: Nested fields.  Since thrift does not support nested fields,
    the nesting is flattened to a single list by a depth-first traversal.
    The children count is used to construct the nested relationship.
    This field is not set when the element is a primitive type
     - converted_type: DEPRECATED: When the schema is the result of a conversion from another model.
    Used to record the original type to help with cross conversion.

    This is superseded by logicalType.
     - scale: DEPRECATED: Used when this column contains decimal data.
    See the DECIMAL converted type for more details.

    This is superseded by using the DecimalType annotation in logicalType.
     - precision
     - field_id: When the original schema supports field ids, this will save the
    original field id in the parquet schema
     - logicalType: The logical type of this SchemaElement

    LogicalType replaces ConvertedType, but ConvertedType is still required
    for some logical types to ensure forward-compatibility in format v1.

    """


    def __init__(self, type=None, type_length=None, repetition_type=None, name=None, num_children=None, converted_type=None, scale=None, precision=None, field_id=None, logicalType=None,):
        self.type = type
        self.type_length = type_length
        self.repetition_type = repetition_type
        self.name = name
        self.num_children = num_children
        self.converted_type = converted_type
        self.scale = scale
        self.precision = precision
        self.field_id = field_id
        self.logicalType = logicalType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.repetition_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.num_children = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.converted_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.scale = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.precision = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.field_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.logicalType = LogicalType()
                    self.logicalType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SchemaElement')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.type_length is not None:
            oprot.writeFieldBegin('type_length', TType.I32, 2)
            oprot.writeI32(self.type_length)
            oprot.writeFieldEnd()
        if self.repetition_type is not None:
            oprot.writeFieldBegin('repetition_type', TType.I32, 3)
            oprot.writeI32(self.repetition_type)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 4)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.num_children is not None:
            oprot.writeFieldBegin('num_children', TType.I32, 5)
            oprot.writeI32(self.num_children)
            oprot.writeFieldEnd()
        if self.converted_type is not None:
            oprot.writeFieldBegin('converted_type', TType.I32, 6)
            oprot.writeI32(self.converted_type)
            oprot.writeFieldEnd()
        if self.scale is not None:
            oprot.writeFieldBegin('scale', TType.I32, 7)
            oprot.writeI32(self.scale)
            oprot.writeFieldEnd()
        if self.precision is not None:
            oprot.writeFieldBegin('precision', TType.I32, 8)
            oprot.writeI32(self.precision)
            oprot.writeFieldEnd()
        if self.field_id is not None:
            oprot.writeFieldBegin('field_id', TType.I32, 9)
            oprot.writeI32(self.field_id)
            oprot.writeFieldEnd()
        if self.logicalType is not None:
            oprot.writeFieldBegin('logicalType', TType.STRUCT, 10)
            self.logicalType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataPageHeader(object):
    """
    Data page header

    Attributes:
     - num_values: Number of values, including NULLs, in this data page. *
     - encoding: Encoding used for this data page *
     - definition_level_encoding: Encoding used for definition levels *
     - repetition_level_encoding: Encoding used for repetition levels *
     - statistics: Optional statistics for the data in this page *

    """


    def __init__(self, num_values=None, encoding=None, definition_level_encoding=None, repetition_level_encoding=None, statistics=None,):
        self.num_values = num_values
        self.encoding = encoding
        self.definition_level_encoding = definition_level_encoding
        self.repetition_level_encoding = repetition_level_encoding
        self.statistics = statistics

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_values = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.definition_level_encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.repetition_level_encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.statistics = Statistics()
                    self.statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataPageHeader')
        if self.num_values is not None:
            oprot.writeFieldBegin('num_values', TType.I32, 1)
            oprot.writeI32(self.num_values)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 2)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.definition_level_encoding is not None:
            oprot.writeFieldBegin('definition_level_encoding', TType.I32, 3)
            oprot.writeI32(self.definition_level_encoding)
            oprot.writeFieldEnd()
        if self.repetition_level_encoding is not None:
            oprot.writeFieldBegin('repetition_level_encoding', TType.I32, 4)
            oprot.writeI32(self.repetition_level_encoding)
            oprot.writeFieldEnd()
        if self.statistics is not None:
            oprot.writeFieldBegin('statistics', TType.STRUCT, 5)
            self.statistics.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_values is None:
            raise TProtocolException(message='Required field num_values is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        if self.definition_level_encoding is None:
            raise TProtocolException(message='Required field definition_level_encoding is unset!')
        if self.repetition_level_encoding is None:
            raise TProtocolException(message='Required field repetition_level_encoding is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class IndexPageHeader(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('IndexPageHeader')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DictionaryPageHeader(object):
    """
    The dictionary page must be placed at the first position of the column chunk
    if it is partly or completely dictionary encoded. At most one dictionary page
    can be placed in a column chunk.


    Attributes:
     - num_values: Number of values in the dictionary *
     - encoding: Encoding using this dictionary page *
     - is_sorted: If true, the entries in the dictionary are sorted in ascending order *

    """


    def __init__(self, num_values=None, encoding=None, is_sorted=None,):
        self.num_values = num_values
        self.encoding = encoding
        self.is_sorted = is_sorted

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_values = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_sorted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DictionaryPageHeader')
        if self.num_values is not None:
            oprot.writeFieldBegin('num_values', TType.I32, 1)
            oprot.writeI32(self.num_values)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 2)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.is_sorted is not None:
            oprot.writeFieldBegin('is_sorted', TType.BOOL, 3)
            oprot.writeBool(self.is_sorted)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_values is None:
            raise TProtocolException(message='Required field num_values is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataPageHeaderV2(object):
    """
    New page format allowing reading levels without decompressing the data
    Repetition and definition levels are uncompressed
    The remaining section containing the data is compressed if is_compressed is true


    Attributes:
     - num_values: Number of values, including NULLs, in this data page. *
     - num_nulls: Number of NULL values, in this data page.
    Number of non-null = num_values - num_nulls which is also the number of values in the data section *
     - num_rows: Number of rows in this data page. which means pages change on record boundaries (r = 0) *
     - encoding: Encoding used for data in this page *
     - definition_levels_byte_length: Length of the definition levels
     - repetition_levels_byte_length: Length of the repetition levels
     - is_compressed: Whether the values are compressed.
    Which means the section of the page between
    definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
    is compressed with the compression_codec.
    If missing it is considered compressed
     - statistics: Optional statistics for the data in this page *

    """


    def __init__(self, num_values=None, num_nulls=None, num_rows=None, encoding=None, definition_levels_byte_length=None, repetition_levels_byte_length=None, is_compressed=True, statistics=None,):
        self.num_values = num_values
        self.num_nulls = num_nulls
        self.num_rows = num_rows
        self.encoding = encoding
        self.definition_levels_byte_length = definition_levels_byte_length
        self.repetition_levels_byte_length = repetition_levels_byte_length
        self.is_compressed = is_compressed
        self.statistics = statistics

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_values = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_nulls = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_rows = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.definition_levels_byte_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.repetition_levels_byte_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_compressed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.statistics = Statistics()
                    self.statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataPageHeaderV2')
        if self.num_values is not None:
            oprot.writeFieldBegin('num_values', TType.I32, 1)
            oprot.writeI32(self.num_values)
            oprot.writeFieldEnd()
        if self.num_nulls is not None:
            oprot.writeFieldBegin('num_nulls', TType.I32, 2)
            oprot.writeI32(self.num_nulls)
            oprot.writeFieldEnd()
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I32, 3)
            oprot.writeI32(self.num_rows)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 4)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.definition_levels_byte_length is not None:
            oprot.writeFieldBegin('definition_levels_byte_length', TType.I32, 5)
            oprot.writeI32(self.definition_levels_byte_length)
            oprot.writeFieldEnd()
        if self.repetition_levels_byte_length is not None:
            oprot.writeFieldBegin('repetition_levels_byte_length', TType.I32, 6)
            oprot.writeI32(self.repetition_levels_byte_length)
            oprot.writeFieldEnd()
        if self.is_compressed is not None:
            oprot.writeFieldBegin('is_compressed', TType.BOOL, 7)
            oprot.writeBool(self.is_compressed)
            oprot.writeFieldEnd()
        if self.statistics is not None:
            oprot.writeFieldBegin('statistics', TType.STRUCT, 8)
            self.statistics.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_values is None:
            raise TProtocolException(message='Required field num_values is unset!')
        if self.num_nulls is None:
            raise TProtocolException(message='Required field num_nulls is unset!')
        if self.num_rows is None:
            raise TProtocolException(message='Required field num_rows is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        if self.definition_levels_byte_length is None:
            raise TProtocolException(message='Required field definition_levels_byte_length is unset!')
        if self.repetition_levels_byte_length is None:
            raise TProtocolException(message='Required field repetition_levels_byte_length is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SplitBlockAlgorithm(object):
    """
    Block-based algorithm type annotation. *

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SplitBlockAlgorithm')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BloomFilterAlgorithm(object):
    """
    The algorithm used in Bloom filter. *

    Attributes:
     - BLOCK: Block-based Bloom filter. *

    """


    def __init__(self, BLOCK=None,):
        self.BLOCK = BLOCK

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.BLOCK = SplitBlockAlgorithm()
                    self.BLOCK.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BloomFilterAlgorithm')
        if self.BLOCK is not None:
            oprot.writeFieldBegin('BLOCK', TType.STRUCT, 1)
            self.BLOCK.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class XxHash(object):
    """
    Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash
    algorithm. It uses 64 bits version of xxHash.


    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('XxHash')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BloomFilterHash(object):
    """
    The hash function used in Bloom filter. This function takes the hash of a column value
    using plain encoding.


    Attributes:
     - XXHASH: xxHash Strategy. *

    """


    def __init__(self, XXHASH=None,):
        self.XXHASH = XXHASH

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.XXHASH = XxHash()
                    self.XXHASH.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BloomFilterHash')
        if self.XXHASH is not None:
            oprot.writeFieldBegin('XXHASH', TType.STRUCT, 1)
            self.XXHASH.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Uncompressed(object):
    """
    The compression used in the Bloom filter.


    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Uncompressed')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BloomFilterCompression(object):
    """
    Attributes:
     - UNCOMPRESSED

    """


    def __init__(self, UNCOMPRESSED=None,):
        self.UNCOMPRESSED = UNCOMPRESSED

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.UNCOMPRESSED = Uncompressed()
                    self.UNCOMPRESSED.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BloomFilterCompression')
        if self.UNCOMPRESSED is not None:
            oprot.writeFieldBegin('UNCOMPRESSED', TType.STRUCT, 1)
            self.UNCOMPRESSED.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BloomFilterHeader(object):
    """
    Bloom filter header is stored at beginning of Bloom filter data of each column
    and followed by its bitset.


    Attributes:
     - numBytes: The size of bitset in bytes *
     - algorithm: The algorithm for setting bits. *
     - hash: The hash function used for Bloom filter. *
     - compression: The compression used in the Bloom filter *

    """


    def __init__(self, numBytes=None, algorithm=None, hash=None, compression=None,):
        self.numBytes = numBytes
        self.algorithm = algorithm
        self.hash = hash
        self.compression = compression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.numBytes = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.algorithm = BloomFilterAlgorithm()
                    self.algorithm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.hash = BloomFilterHash()
                    self.hash.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.compression = BloomFilterCompression()
                    self.compression.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BloomFilterHeader')
        if self.numBytes is not None:
            oprot.writeFieldBegin('numBytes', TType.I32, 1)
            oprot.writeI32(self.numBytes)
            oprot.writeFieldEnd()
        if self.algorithm is not None:
            oprot.writeFieldBegin('algorithm', TType.STRUCT, 2)
            self.algorithm.write(oprot)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRUCT, 3)
            self.hash.write(oprot)
            oprot.writeFieldEnd()
        if self.compression is not None:
            oprot.writeFieldBegin('compression', TType.STRUCT, 4)
            self.compression.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.numBytes is None:
            raise TProtocolException(message='Required field numBytes is unset!')
        if self.algorithm is None:
            raise TProtocolException(message='Required field algorithm is unset!')
        if self.hash is None:
            raise TProtocolException(message='Required field hash is unset!')
        if self.compression is None:
            raise TProtocolException(message='Required field compression is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PageHeader(object):
    """
    Attributes:
     - type: the type of the page: indicates which of the *_header fields is set *
     - uncompressed_page_size: Uncompressed page size in bytes (not including this header) *
     - compressed_page_size: Compressed (and potentially encrypted) page size in bytes, not including this header *
     - crc: The 32-bit CRC checksum for the page, to be be calculated as follows:

    - The standard CRC32 algorithm is used (with polynomial 0x04C11DB7,
      the same as in e.g. GZip).
    - All page types can have a CRC (v1 and v2 data pages, dictionary pages,
      etc.).
    - The CRC is computed on the serialization binary representation of the page
      (as written to disk), excluding the page header. For example, for v1
      data pages, the CRC is computed on the concatenation of repetition levels,
      definition levels and column values (optionally compressed, optionally
      encrypted).
    - The CRC computation therefore takes place after any compression
      and encryption steps, if any.

    If enabled, this allows for disabling checksumming in HDFS if only a few
    pages need to be read.
     - data_page_header
     - index_page_header
     - dictionary_page_header
     - data_page_header_v2

    """


    def __init__(self, type=None, uncompressed_page_size=None, compressed_page_size=None, crc=None, data_page_header=None, index_page_header=None, dictionary_page_header=None, data_page_header_v2=None,):
        self.type = type
        self.uncompressed_page_size = uncompressed_page_size
        self.compressed_page_size = compressed_page_size
        self.crc = crc
        self.data_page_header = data_page_header
        self.index_page_header = index_page_header
        self.dictionary_page_header = dictionary_page_header
        self.data_page_header_v2 = data_page_header_v2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.uncompressed_page_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.compressed_page_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.crc = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.data_page_header = DataPageHeader()
                    self.data_page_header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.index_page_header = IndexPageHeader()
                    self.index_page_header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.dictionary_page_header = DictionaryPageHeader()
                    self.dictionary_page_header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.data_page_header_v2 = DataPageHeaderV2()
                    self.data_page_header_v2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PageHeader')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.uncompressed_page_size is not None:
            oprot.writeFieldBegin('uncompressed_page_size', TType.I32, 2)
            oprot.writeI32(self.uncompressed_page_size)
            oprot.writeFieldEnd()
        if self.compressed_page_size is not None:
            oprot.writeFieldBegin('compressed_page_size', TType.I32, 3)
            oprot.writeI32(self.compressed_page_size)
            oprot.writeFieldEnd()
        if self.crc is not None:
            oprot.writeFieldBegin('crc', TType.I32, 4)
            oprot.writeI32(self.crc)
            oprot.writeFieldEnd()
        if self.data_page_header is not None:
            oprot.writeFieldBegin('data_page_header', TType.STRUCT, 5)
            self.data_page_header.write(oprot)
            oprot.writeFieldEnd()
        if self.index_page_header is not None:
            oprot.writeFieldBegin('index_page_header', TType.STRUCT, 6)
            self.index_page_header.write(oprot)
            oprot.writeFieldEnd()
        if self.dictionary_page_header is not None:
            oprot.writeFieldBegin('dictionary_page_header', TType.STRUCT, 7)
            self.dictionary_page_header.write(oprot)
            oprot.writeFieldEnd()
        if self.data_page_header_v2 is not None:
            oprot.writeFieldBegin('data_page_header_v2', TType.STRUCT, 8)
            self.data_page_header_v2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.uncompressed_page_size is None:
            raise TProtocolException(message='Required field uncompressed_page_size is unset!')
        if self.compressed_page_size is None:
            raise TProtocolException(message='Required field compressed_page_size is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KeyValue(object):
    """
    Wrapper struct to store key values

    Attributes:
     - key
     - value

    """


    def __init__(self, key=None, value=None,):
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KeyValue')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SortingColumn(object):
    """
    Wrapper struct to specify sort order

    Attributes:
     - column_idx: The column index (in this row group) *
     - descending: If true, indicates this column is sorted in descending order. *
     - nulls_first: If true, nulls will come before non-null values, otherwise,
    nulls go at the end.

    """


    def __init__(self, column_idx=None, descending=None, nulls_first=None,):
        self.column_idx = column_idx
        self.descending = descending
        self.nulls_first = nulls_first

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.column_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.descending = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.nulls_first = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SortingColumn')
        if self.column_idx is not None:
            oprot.writeFieldBegin('column_idx', TType.I32, 1)
            oprot.writeI32(self.column_idx)
            oprot.writeFieldEnd()
        if self.descending is not None:
            oprot.writeFieldBegin('descending', TType.BOOL, 2)
            oprot.writeBool(self.descending)
            oprot.writeFieldEnd()
        if self.nulls_first is not None:
            oprot.writeFieldBegin('nulls_first', TType.BOOL, 3)
            oprot.writeBool(self.nulls_first)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.column_idx is None:
            raise TProtocolException(message='Required field column_idx is unset!')
        if self.descending is None:
            raise TProtocolException(message='Required field descending is unset!')
        if self.nulls_first is None:
            raise TProtocolException(message='Required field nulls_first is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PageEncodingStats(object):
    """
    statistics of a given page type and encoding

    Attributes:
     - page_type: the page type (data/dic/...) *
     - encoding: encoding of the page *
     - count: number of pages of this type with this encoding *

    """


    def __init__(self, page_type=None, encoding=None, count=None,):
        self.page_type = page_type
        self.encoding = encoding
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.page_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PageEncodingStats')
        if self.page_type is not None:
            oprot.writeFieldBegin('page_type', TType.I32, 1)
            oprot.writeI32(self.page_type)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 2)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.page_type is None:
            raise TProtocolException(message='Required field page_type is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        if self.count is None:
            raise TProtocolException(message='Required field count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnMetaData(object):
    """
    Description for column metadata

    Attributes:
     - type: Type of this column *
     - encodings: Set of all encodings used for this column. The purpose is to validate
    whether we can decode those pages. *
     - path_in_schema: Path in schema *
     - codec: Compression codec *
     - num_values: Number of values in this column *
     - total_uncompressed_size: total byte size of all uncompressed pages in this column chunk (including the headers) *
     - total_compressed_size: total byte size of all compressed, and potentially encrypted, pages
    in this column chunk (including the headers) *
     - key_value_metadata: Optional key/value metadata *
     - data_page_offset: Byte offset from beginning of file to first data page *
     - index_page_offset: Byte offset from beginning of file to root index page *
     - dictionary_page_offset: Byte offset from the beginning of file to first (only) dictionary page *
     - statistics: optional statistics for this column chunk
     - encoding_stats: Set of all encodings used for pages in this column chunk.
    This information can be used to determine if all data pages are
    dictionary encoded for example *
     - bloom_filter_offset: Byte offset from beginning of file to Bloom filter data. *
     - bloom_filter_length: Size of Bloom filter data including the serialized header, in bytes.
    Added in 2.10 so readers may not read this field from old files and
    it can be obtained after the BloomFilterHeader has been deserialized.
    Writers should write this field so readers can read the bloom filter
    in a single I/O.
     - size_statistics: Optional statistics to help estimate total memory when converted to in-memory
    representations. The histograms contained in these statistics can
    also be useful in some cases for more fine-grained nullability/list length
    filter pushdown.

    """


    def __init__(self, type=None, encodings=None, path_in_schema=None, codec=None, num_values=None, total_uncompressed_size=None, total_compressed_size=None, key_value_metadata=None, data_page_offset=None, index_page_offset=None, dictionary_page_offset=None, statistics=None, encoding_stats=None, bloom_filter_offset=None, bloom_filter_length=None, size_statistics=None,):
        self.type = type
        self.encodings = encodings
        self.path_in_schema = path_in_schema
        self.codec = codec
        self.num_values = num_values
        self.total_uncompressed_size = total_uncompressed_size
        self.total_compressed_size = total_compressed_size
        self.key_value_metadata = key_value_metadata
        self.data_page_offset = data_page_offset
        self.index_page_offset = index_page_offset
        self.dictionary_page_offset = dictionary_page_offset
        self.statistics = statistics
        self.encoding_stats = encoding_stats
        self.bloom_filter_offset = bloom_filter_offset
        self.bloom_filter_length = bloom_filter_length
        self.size_statistics = size_statistics

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.encodings.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.path_in_schema = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.path_in_schema.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.codec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.num_values = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.total_uncompressed_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.total_compressed_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.key_value_metadata = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = KeyValue()
                        _elem31.read(iprot)
                        self.key_value_metadata.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.data_page_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.index_page_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.dictionary_page_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.statistics = Statistics()
                    self.statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.encoding_stats = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = PageEncodingStats()
                        _elem37.read(iprot)
                        self.encoding_stats.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.bloom_filter_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.bloom_filter_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.size_statistics = SizeStatistics()
                    self.size_statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnMetaData')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter38 in self.encodings:
                oprot.writeI32(iter38)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.path_in_schema is not None:
            oprot.writeFieldBegin('path_in_schema', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.path_in_schema))
            for iter39 in self.path_in_schema:
                oprot.writeString(iter39.encode('utf-8') if sys.version_info[0] == 2 else iter39)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.codec is not None:
            oprot.writeFieldBegin('codec', TType.I32, 4)
            oprot.writeI32(self.codec)
            oprot.writeFieldEnd()
        if self.num_values is not None:
            oprot.writeFieldBegin('num_values', TType.I64, 5)
            oprot.writeI64(self.num_values)
            oprot.writeFieldEnd()
        if self.total_uncompressed_size is not None:
            oprot.writeFieldBegin('total_uncompressed_size', TType.I64, 6)
            oprot.writeI64(self.total_uncompressed_size)
            oprot.writeFieldEnd()
        if self.total_compressed_size is not None:
            oprot.writeFieldBegin('total_compressed_size', TType.I64, 7)
            oprot.writeI64(self.total_compressed_size)
            oprot.writeFieldEnd()
        if self.key_value_metadata is not None:
            oprot.writeFieldBegin('key_value_metadata', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.key_value_metadata))
            for iter40 in self.key_value_metadata:
                iter40.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.data_page_offset is not None:
            oprot.writeFieldBegin('data_page_offset', TType.I64, 9)
            oprot.writeI64(self.data_page_offset)
            oprot.writeFieldEnd()
        if self.index_page_offset is not None:
            oprot.writeFieldBegin('index_page_offset', TType.I64, 10)
            oprot.writeI64(self.index_page_offset)
            oprot.writeFieldEnd()
        if self.dictionary_page_offset is not None:
            oprot.writeFieldBegin('dictionary_page_offset', TType.I64, 11)
            oprot.writeI64(self.dictionary_page_offset)
            oprot.writeFieldEnd()
        if self.statistics is not None:
            oprot.writeFieldBegin('statistics', TType.STRUCT, 12)
            self.statistics.write(oprot)
            oprot.writeFieldEnd()
        if self.encoding_stats is not None:
            oprot.writeFieldBegin('encoding_stats', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.encoding_stats))
            for iter41 in self.encoding_stats:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bloom_filter_offset is not None:
            oprot.writeFieldBegin('bloom_filter_offset', TType.I64, 14)
            oprot.writeI64(self.bloom_filter_offset)
            oprot.writeFieldEnd()
        if self.bloom_filter_length is not None:
            oprot.writeFieldBegin('bloom_filter_length', TType.I32, 15)
            oprot.writeI32(self.bloom_filter_length)
            oprot.writeFieldEnd()
        if self.size_statistics is not None:
            oprot.writeFieldBegin('size_statistics', TType.STRUCT, 16)
            self.size_statistics.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.path_in_schema is None:
            raise TProtocolException(message='Required field path_in_schema is unset!')
        if self.codec is None:
            raise TProtocolException(message='Required field codec is unset!')
        if self.num_values is None:
            raise TProtocolException(message='Required field num_values is unset!')
        if self.total_uncompressed_size is None:
            raise TProtocolException(message='Required field total_uncompressed_size is unset!')
        if self.total_compressed_size is None:
            raise TProtocolException(message='Required field total_compressed_size is unset!')
        if self.data_page_offset is None:
            raise TProtocolException(message='Required field data_page_offset is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EncryptionWithFooterKey(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EncryptionWithFooterKey')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EncryptionWithColumnKey(object):
    """
    Attributes:
     - path_in_schema: Column path in schema *
     - key_metadata: Retrieval metadata of column encryption key *

    """


    def __init__(self, path_in_schema=None, key_metadata=None,):
        self.path_in_schema = path_in_schema
        self.key_metadata = key_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.path_in_schema = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.path_in_schema.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key_metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EncryptionWithColumnKey')
        if self.path_in_schema is not None:
            oprot.writeFieldBegin('path_in_schema', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.path_in_schema))
            for iter48 in self.path_in_schema:
                oprot.writeString(iter48.encode('utf-8') if sys.version_info[0] == 2 else iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.key_metadata is not None:
            oprot.writeFieldBegin('key_metadata', TType.STRING, 2)
            oprot.writeBinary(self.key_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.path_in_schema is None:
            raise TProtocolException(message='Required field path_in_schema is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnCryptoMetaData(object):
    """
    Attributes:
     - ENCRYPTION_WITH_FOOTER_KEY
     - ENCRYPTION_WITH_COLUMN_KEY

    """


    def __init__(self, ENCRYPTION_WITH_FOOTER_KEY=None, ENCRYPTION_WITH_COLUMN_KEY=None,):
        self.ENCRYPTION_WITH_FOOTER_KEY = ENCRYPTION_WITH_FOOTER_KEY
        self.ENCRYPTION_WITH_COLUMN_KEY = ENCRYPTION_WITH_COLUMN_KEY

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ENCRYPTION_WITH_FOOTER_KEY = EncryptionWithFooterKey()
                    self.ENCRYPTION_WITH_FOOTER_KEY.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ENCRYPTION_WITH_COLUMN_KEY = EncryptionWithColumnKey()
                    self.ENCRYPTION_WITH_COLUMN_KEY.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnCryptoMetaData')
        if self.ENCRYPTION_WITH_FOOTER_KEY is not None:
            oprot.writeFieldBegin('ENCRYPTION_WITH_FOOTER_KEY', TType.STRUCT, 1)
            self.ENCRYPTION_WITH_FOOTER_KEY.write(oprot)
            oprot.writeFieldEnd()
        if self.ENCRYPTION_WITH_COLUMN_KEY is not None:
            oprot.writeFieldBegin('ENCRYPTION_WITH_COLUMN_KEY', TType.STRUCT, 2)
            self.ENCRYPTION_WITH_COLUMN_KEY.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnChunk(object):
    """
    Attributes:
     - file_path: File where column data is stored.  If not set, assumed to be same file as
    metadata.  This path is relative to the current file.

     - file_offset: Byte offset in file_path to the ColumnMetaData *
     - meta_data: Column metadata for this chunk. This is the same content as what is at
    file_path/file_offset.  Having it here has it replicated in the file
    metadata.

     - offset_index_offset: File offset of ColumnChunk's OffsetIndex *
     - offset_index_length: Size of ColumnChunk's OffsetIndex, in bytes *
     - column_index_offset: File offset of ColumnChunk's ColumnIndex *
     - column_index_length: Size of ColumnChunk's ColumnIndex, in bytes *
     - crypto_metadata: Crypto metadata of encrypted columns *
     - encrypted_column_metadata: Encrypted column metadata for this chunk *

    """


    def __init__(self, file_path=None, file_offset=None, meta_data=None, offset_index_offset=None, offset_index_length=None, column_index_offset=None, column_index_length=None, crypto_metadata=None, encrypted_column_metadata=None,):
        self.file_path = file_path
        self.file_offset = file_offset
        self.meta_data = meta_data
        self.offset_index_offset = offset_index_offset
        self.offset_index_length = offset_index_length
        self.column_index_offset = column_index_offset
        self.column_index_length = column_index_length
        self.crypto_metadata = crypto_metadata
        self.encrypted_column_metadata = encrypted_column_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.file_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.meta_data = ColumnMetaData()
                    self.meta_data.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset_index_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.offset_index_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.column_index_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.column_index_length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.crypto_metadata = ColumnCryptoMetaData()
                    self.crypto_metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.encrypted_column_metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnChunk')
        if self.file_path is not None:
            oprot.writeFieldBegin('file_path', TType.STRING, 1)
            oprot.writeString(self.file_path.encode('utf-8') if sys.version_info[0] == 2 else self.file_path)
            oprot.writeFieldEnd()
        if self.file_offset is not None:
            oprot.writeFieldBegin('file_offset', TType.I64, 2)
            oprot.writeI64(self.file_offset)
            oprot.writeFieldEnd()
        if self.meta_data is not None:
            oprot.writeFieldBegin('meta_data', TType.STRUCT, 3)
            self.meta_data.write(oprot)
            oprot.writeFieldEnd()
        if self.offset_index_offset is not None:
            oprot.writeFieldBegin('offset_index_offset', TType.I64, 4)
            oprot.writeI64(self.offset_index_offset)
            oprot.writeFieldEnd()
        if self.offset_index_length is not None:
            oprot.writeFieldBegin('offset_index_length', TType.I32, 5)
            oprot.writeI32(self.offset_index_length)
            oprot.writeFieldEnd()
        if self.column_index_offset is not None:
            oprot.writeFieldBegin('column_index_offset', TType.I64, 6)
            oprot.writeI64(self.column_index_offset)
            oprot.writeFieldEnd()
        if self.column_index_length is not None:
            oprot.writeFieldBegin('column_index_length', TType.I32, 7)
            oprot.writeI32(self.column_index_length)
            oprot.writeFieldEnd()
        if self.crypto_metadata is not None:
            oprot.writeFieldBegin('crypto_metadata', TType.STRUCT, 8)
            self.crypto_metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.encrypted_column_metadata is not None:
            oprot.writeFieldBegin('encrypted_column_metadata', TType.STRING, 9)
            oprot.writeBinary(self.encrypted_column_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_offset is None:
            raise TProtocolException(message='Required field file_offset is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RowGroup(object):
    """
    Attributes:
     - columns: Metadata for each column chunk in this row group.
    This list must have the same order as the SchemaElement list in FileMetaData.

     - total_byte_size: Total byte size of all the uncompressed column data in this row group *
     - num_rows: Number of rows in this row group *
     - sorting_columns: If set, specifies a sort ordering of the rows in this RowGroup.
    The sorting columns can be a subset of all the columns.
     - file_offset: Byte offset from beginning of file to first page (data or dictionary)
    in this row group *
     - total_compressed_size: Total byte size of all compressed (and potentially encrypted) column data
    in this row group *
     - ordinal: Row group ordinal in the file *

    """


    def __init__(self, columns=None, total_byte_size=None, num_rows=None, sorting_columns=None, file_offset=None, total_compressed_size=None, ordinal=None,):
        self.columns = columns
        self.total_byte_size = total_byte_size
        self.num_rows = num_rows
        self.sorting_columns = sorting_columns
        self.file_offset = file_offset
        self.total_compressed_size = total_compressed_size
        self.ordinal = ordinal

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = ColumnChunk()
                        _elem54.read(iprot)
                        self.columns.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.total_byte_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sorting_columns = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = SortingColumn()
                        _elem60.read(iprot)
                        self.sorting_columns.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.file_offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.total_compressed_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I16:
                    self.ordinal = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RowGroup')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter61 in self.columns:
                iter61.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.total_byte_size is not None:
            oprot.writeFieldBegin('total_byte_size', TType.I64, 2)
            oprot.writeI64(self.total_byte_size)
            oprot.writeFieldEnd()
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 3)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        if self.sorting_columns is not None:
            oprot.writeFieldBegin('sorting_columns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.sorting_columns))
            for iter62 in self.sorting_columns:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.file_offset is not None:
            oprot.writeFieldBegin('file_offset', TType.I64, 5)
            oprot.writeI64(self.file_offset)
            oprot.writeFieldEnd()
        if self.total_compressed_size is not None:
            oprot.writeFieldBegin('total_compressed_size', TType.I64, 6)
            oprot.writeI64(self.total_compressed_size)
            oprot.writeFieldEnd()
        if self.ordinal is not None:
            oprot.writeFieldBegin('ordinal', TType.I16, 7)
            oprot.writeI16(self.ordinal)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.total_byte_size is None:
            raise TProtocolException(message='Required field total_byte_size is unset!')
        if self.num_rows is None:
            raise TProtocolException(message='Required field num_rows is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TypeDefinedOrder(object):
    """
    Empty struct to signal the order defined by the physical or logical type

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TypeDefinedOrder')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnOrder(object):
    """
    Union to specify the order used for the min_value and max_value fields for a
    column. This union takes the role of an enhanced enum that allows rich
    elements (which will be needed for a collation-based ordering in the future).

    Possible values are:
    * TypeDefinedOrder - the column uses the order defined by its logical or
                         physical type (if there is no logical type).

    If the reader does not support the value of this union, min and max stats
    for this column should be ignored.

    Attributes:
     - TYPE_ORDER: The sort orders for logical types are:
      UTF8 - unsigned byte-wise comparison
      INT8 - signed comparison
      INT16 - signed comparison
      INT32 - signed comparison
      INT64 - signed comparison
      UINT8 - unsigned comparison
      UINT16 - unsigned comparison
      UINT32 - unsigned comparison
      UINT64 - unsigned comparison
      DECIMAL - signed comparison of the represented value
      DATE - signed comparison
      TIME_MILLIS - signed comparison
      TIME_MICROS - signed comparison
      TIMESTAMP_MILLIS - signed comparison
      TIMESTAMP_MICROS - signed comparison
      INTERVAL - undefined
      JSON - unsigned byte-wise comparison
      BSON - unsigned byte-wise comparison
      ENUM - unsigned byte-wise comparison
      LIST - undefined
      MAP - undefined

    In the absence of logical types, the sort order is determined by the physical type:
      BOOLEAN - false, true
      INT32 - signed comparison
      INT64 - signed comparison
      INT96 (only used for legacy timestamps) - undefined
      FLOAT - signed comparison of the represented value (*)
      DOUBLE - signed comparison of the represented value (*)
      BYTE_ARRAY - unsigned byte-wise comparison
      FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison

    (*) Because the sorting order is not specified properly for floating
        point values (relations vs. total ordering) the following
        compatibility rules should be applied when reading statistics:
        - If the min is a NaN, it should be ignored.
        - If the max is a NaN, it should be ignored.
        - If the min is +0, the row group may contain -0 values as well.
        - If the max is -0, the row group may contain +0 values as well.
        - When looking for NaN values, min and max should be ignored.

        When writing statistics the following rules should be followed:
        - NaNs should not be written to min or max statistics fields.
        - If the computed max value is zero (whether negative or positive),
          `+0.0` should be written into the max statistics field.
        - If the computed min value is zero (whether negative or positive),
          `-0.0` should be written into the min statistics field.

    """


    def __init__(self, TYPE_ORDER=None,):
        self.TYPE_ORDER = TYPE_ORDER

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.TYPE_ORDER = TypeDefinedOrder()
                    self.TYPE_ORDER.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnOrder')
        if self.TYPE_ORDER is not None:
            oprot.writeFieldBegin('TYPE_ORDER', TType.STRUCT, 1)
            self.TYPE_ORDER.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PageLocation(object):
    """
    Attributes:
     - offset: Offset of the page in the file *
     - compressed_page_size: Size of the page, including header. Sum of compressed_page_size and header
    length
     - first_row_index: Index within the RowGroup of the first row of the page; this means pages
    change on record boundaries (r = 0).

    """


    def __init__(self, offset=None, compressed_page_size=None, first_row_index=None,):
        self.offset = offset
        self.compressed_page_size = compressed_page_size
        self.first_row_index = first_row_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.compressed_page_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.first_row_index = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PageLocation')
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 1)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.compressed_page_size is not None:
            oprot.writeFieldBegin('compressed_page_size', TType.I32, 2)
            oprot.writeI32(self.compressed_page_size)
            oprot.writeFieldEnd()
        if self.first_row_index is not None:
            oprot.writeFieldBegin('first_row_index', TType.I64, 3)
            oprot.writeI64(self.first_row_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.compressed_page_size is None:
            raise TProtocolException(message='Required field compressed_page_size is unset!')
        if self.first_row_index is None:
            raise TProtocolException(message='Required field first_row_index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class OffsetIndex(object):
    """
    Attributes:
     - page_locations: PageLocations, ordered by increasing PageLocation.offset. It is required
    that page_locations[i].first_row_index < page_locations[i+1].first_row_index.
     - unencoded_byte_array_data_bytes: Unencoded/uncompressed size for BYTE_ARRAY types.

    See documention for unencoded_byte_array_data_bytes in SizeStatistics for
    more details on this field.

    """


    def __init__(self, page_locations=None, unencoded_byte_array_data_bytes=None,):
        self.page_locations = page_locations
        self.unencoded_byte_array_data_bytes = unencoded_byte_array_data_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.page_locations = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = PageLocation()
                        _elem68.read(iprot)
                        self.page_locations.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.unencoded_byte_array_data_bytes = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = iprot.readI64()
                        self.unencoded_byte_array_data_bytes.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('OffsetIndex')
        if self.page_locations is not None:
            oprot.writeFieldBegin('page_locations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.page_locations))
            for iter75 in self.page_locations:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.unencoded_byte_array_data_bytes is not None:
            oprot.writeFieldBegin('unencoded_byte_array_data_bytes', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.unencoded_byte_array_data_bytes))
            for iter76 in self.unencoded_byte_array_data_bytes:
                oprot.writeI64(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.page_locations is None:
            raise TProtocolException(message='Required field page_locations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnIndex(object):
    """
    Description for ColumnIndex.
    Each <array-field>[i] refers to the page at OffsetIndex.page_locations[i]

    Attributes:
     - null_pages: A list of Boolean values to determine the validity of the corresponding
    min and max values. If true, a page contains only null values, and writers
    have to set the corresponding entries in min_values and max_values to
    byte[0], so that all lists have the same length. If false, the
    corresponding entries in min_values and max_values must be valid.
     - min_values: Two lists containing lower and upper bounds for the values of each page
    determined by the ColumnOrder of the column. These may be the actual
    minimum and maximum values found on a page, but can also be (more compact)
    values that do not exist on a page. For example, instead of storing ""Blart
    Versenwald III", a writer may set min_values[i]="B", max_values[i]="C".
    Such more compact values must still be valid values within the column's
    logical type. Readers must make sure that list entries are populated before
    using them by inspecting null_pages.
     - max_values
     - boundary_order: Stores whether both min_values and max_values are ordered and if so, in
    which direction. This allows readers to perform binary searches in both
    lists. Readers cannot assume that max_values[i] <= min_values[i+1], even
    if the lists are ordered.
     - null_counts: A list containing the number of null values for each page *
     - repetition_level_histograms: Contains repetition level histograms for each page
    concatenated together.  The repetition_level_histogram field on
    SizeStatistics contains more details.

    When present the length should always be (number of pages *
    (max_repetition_level + 1)) elements.

    Element 0 is the first element of the histogram for the first page.
    Element (max_repetition_level + 1) is the first element of the histogram
    for the second page.

     - definition_level_histograms: Same as repetition_level_histograms except for definitions levels.


    """


    def __init__(self, null_pages=None, min_values=None, max_values=None, boundary_order=None, null_counts=None, repetition_level_histograms=None, definition_level_histograms=None,):
        self.null_pages = null_pages
        self.min_values = min_values
        self.max_values = max_values
        self.boundary_order = boundary_order
        self.null_counts = null_counts
        self.repetition_level_histograms = repetition_level_histograms
        self.definition_level_histograms = definition_level_histograms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.null_pages = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readBool()
                        self.null_pages.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.min_values = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = iprot.readBinary()
                        self.min_values.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.max_values = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = iprot.readBinary()
                        self.max_values.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.boundary_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.null_counts = []
                    (_etype98, _size95) = iprot.readListBegin()
                    for _i99 in range(_size95):
                        _elem100 = iprot.readI64()
                        self.null_counts.append(_elem100)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.repetition_level_histograms = []
                    (_etype104, _size101) = iprot.readListBegin()
                    for _i105 in range(_size101):
                        _elem106 = iprot.readI64()
                        self.repetition_level_histograms.append(_elem106)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.definition_level_histograms = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = iprot.readI64()
                        self.definition_level_histograms.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnIndex')
        if self.null_pages is not None:
            oprot.writeFieldBegin('null_pages', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.null_pages))
            for iter113 in self.null_pages:
                oprot.writeBool(iter113)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.min_values is not None:
            oprot.writeFieldBegin('min_values', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.min_values))
            for iter114 in self.min_values:
                oprot.writeBinary(iter114)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_values is not None:
            oprot.writeFieldBegin('max_values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.max_values))
            for iter115 in self.max_values:
                oprot.writeBinary(iter115)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.boundary_order is not None:
            oprot.writeFieldBegin('boundary_order', TType.I32, 4)
            oprot.writeI32(self.boundary_order)
            oprot.writeFieldEnd()
        if self.null_counts is not None:
            oprot.writeFieldBegin('null_counts', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.null_counts))
            for iter116 in self.null_counts:
                oprot.writeI64(iter116)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.repetition_level_histograms is not None:
            oprot.writeFieldBegin('repetition_level_histograms', TType.LIST, 6)
            oprot.writeListBegin(TType.I64, len(self.repetition_level_histograms))
            for iter117 in self.repetition_level_histograms:
                oprot.writeI64(iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.definition_level_histograms is not None:
            oprot.writeFieldBegin('definition_level_histograms', TType.LIST, 7)
            oprot.writeListBegin(TType.I64, len(self.definition_level_histograms))
            for iter118 in self.definition_level_histograms:
                oprot.writeI64(iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.null_pages is None:
            raise TProtocolException(message='Required field null_pages is unset!')
        if self.min_values is None:
            raise TProtocolException(message='Required field min_values is unset!')
        if self.max_values is None:
            raise TProtocolException(message='Required field max_values is unset!')
        if self.boundary_order is None:
            raise TProtocolException(message='Required field boundary_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AesGcmV1(object):
    """
    Attributes:
     - aad_prefix: AAD prefix *
     - aad_file_unique: Unique file identifier part of AAD suffix *
     - supply_aad_prefix: In files encrypted with AAD prefix without storing it,
    readers must supply the prefix *

    """


    def __init__(self, aad_prefix=None, aad_file_unique=None, supply_aad_prefix=None,):
        self.aad_prefix = aad_prefix
        self.aad_file_unique = aad_file_unique
        self.supply_aad_prefix = supply_aad_prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.aad_prefix = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.aad_file_unique = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.supply_aad_prefix = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AesGcmV1')
        if self.aad_prefix is not None:
            oprot.writeFieldBegin('aad_prefix', TType.STRING, 1)
            oprot.writeBinary(self.aad_prefix)
            oprot.writeFieldEnd()
        if self.aad_file_unique is not None:
            oprot.writeFieldBegin('aad_file_unique', TType.STRING, 2)
            oprot.writeBinary(self.aad_file_unique)
            oprot.writeFieldEnd()
        if self.supply_aad_prefix is not None:
            oprot.writeFieldBegin('supply_aad_prefix', TType.BOOL, 3)
            oprot.writeBool(self.supply_aad_prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AesGcmCtrV1(object):
    """
    Attributes:
     - aad_prefix: AAD prefix *
     - aad_file_unique: Unique file identifier part of AAD suffix *
     - supply_aad_prefix: In files encrypted with AAD prefix without storing it,
    readers must supply the prefix *

    """


    def __init__(self, aad_prefix=None, aad_file_unique=None, supply_aad_prefix=None,):
        self.aad_prefix = aad_prefix
        self.aad_file_unique = aad_file_unique
        self.supply_aad_prefix = supply_aad_prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.aad_prefix = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.aad_file_unique = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.supply_aad_prefix = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AesGcmCtrV1')
        if self.aad_prefix is not None:
            oprot.writeFieldBegin('aad_prefix', TType.STRING, 1)
            oprot.writeBinary(self.aad_prefix)
            oprot.writeFieldEnd()
        if self.aad_file_unique is not None:
            oprot.writeFieldBegin('aad_file_unique', TType.STRING, 2)
            oprot.writeBinary(self.aad_file_unique)
            oprot.writeFieldEnd()
        if self.supply_aad_prefix is not None:
            oprot.writeFieldBegin('supply_aad_prefix', TType.BOOL, 3)
            oprot.writeBool(self.supply_aad_prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EncryptionAlgorithm(object):
    """
    Attributes:
     - AES_GCM_V1
     - AES_GCM_CTR_V1

    """


    def __init__(self, AES_GCM_V1=None, AES_GCM_CTR_V1=None,):
        self.AES_GCM_V1 = AES_GCM_V1
        self.AES_GCM_CTR_V1 = AES_GCM_CTR_V1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.AES_GCM_V1 = AesGcmV1()
                    self.AES_GCM_V1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.AES_GCM_CTR_V1 = AesGcmCtrV1()
                    self.AES_GCM_CTR_V1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EncryptionAlgorithm')
        if self.AES_GCM_V1 is not None:
            oprot.writeFieldBegin('AES_GCM_V1', TType.STRUCT, 1)
            self.AES_GCM_V1.write(oprot)
            oprot.writeFieldEnd()
        if self.AES_GCM_CTR_V1 is not None:
            oprot.writeFieldBegin('AES_GCM_CTR_V1', TType.STRUCT, 2)
            self.AES_GCM_CTR_V1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FileMetaData(object):
    """
    Description for file metadata

    Attributes:
     - version: Version of this file *
     - schema: Parquet schema for this file.  This schema contains metadata for all the columns.
    The schema is represented as a tree with a single root.  The nodes of the tree
    are flattened to a list by doing a depth-first traversal.
    The column metadata contains the path in the schema for that column which can be
    used to map columns to nodes in the schema.
    The first element is the root *
     - num_rows: Number of rows in this file *
     - row_groups: Row groups in this file *
     - key_value_metadata: Optional key/value metadata *
     - created_by: String for application that wrote this file.  This should be in the format
    <Application> version <App Version> (build <App Build Hash>).
    e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)

     - column_orders: Sort order used for the min_value and max_value fields in the Statistics
    objects and the min_values and max_values fields in the ColumnIndex
    objects of each column in this file. Sort orders are listed in the order
    matching the columns in the schema. The indexes are not necessary the same
    though, because only leaf nodes of the schema are represented in the list
    of sort orders.

    Without column_orders, the meaning of the min_value and max_value fields
    in the Statistics object and the ColumnIndex object is undefined. To ensure
    well-defined behaviour, if these fields are written to a Parquet file,
    column_orders must be written as well.

    The obsolete min and max fields in the Statistics object are always sorted
    by signed comparison regardless of column_orders.
     - encryption_algorithm: Encryption algorithm. This field is set only in encrypted files
    with plaintext footer. Files with encrypted footer store algorithm id
    in FileCryptoMetaData structure.
     - footer_signing_key_metadata: Retrieval metadata of key used for signing the footer.
    Used only in encrypted files with plaintext footer.

    """


    def __init__(self, version=None, schema=None, num_rows=None, row_groups=None, key_value_metadata=None, created_by=None, column_orders=None, encryption_algorithm=None, footer_signing_key_metadata=None,):
        self.version = version
        self.schema = schema
        self.num_rows = num_rows
        self.row_groups = row_groups
        self.key_value_metadata = key_value_metadata
        self.created_by = created_by
        self.column_orders = column_orders
        self.encryption_algorithm = encryption_algorithm
        self.footer_signing_key_metadata = footer_signing_key_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.schema = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = SchemaElement()
                        _elem124.read(iprot)
                        self.schema.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.row_groups = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = RowGroup()
                        _elem130.read(iprot)
                        self.row_groups.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.key_value_metadata = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = KeyValue()
                        _elem136.read(iprot)
                        self.key_value_metadata.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.created_by = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.column_orders = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = ColumnOrder()
                        _elem142.read(iprot)
                        self.column_orders.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.encryption_algorithm = EncryptionAlgorithm()
                    self.encryption_algorithm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.footer_signing_key_metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FileMetaData')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I32, 1)
            oprot.writeI32(self.version)
            oprot.writeFieldEnd()
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.schema))
            for iter143 in self.schema:
                iter143.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 3)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        if self.row_groups is not None:
            oprot.writeFieldBegin('row_groups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.row_groups))
            for iter144 in self.row_groups:
                iter144.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.key_value_metadata is not None:
            oprot.writeFieldBegin('key_value_metadata', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.key_value_metadata))
            for iter145 in self.key_value_metadata:
                iter145.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.created_by is not None:
            oprot.writeFieldBegin('created_by', TType.STRING, 6)
            oprot.writeString(self.created_by.encode('utf-8') if sys.version_info[0] == 2 else self.created_by)
            oprot.writeFieldEnd()
        if self.column_orders is not None:
            oprot.writeFieldBegin('column_orders', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.column_orders))
            for iter146 in self.column_orders:
                iter146.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encryption_algorithm is not None:
            oprot.writeFieldBegin('encryption_algorithm', TType.STRUCT, 8)
            self.encryption_algorithm.write(oprot)
            oprot.writeFieldEnd()
        if self.footer_signing_key_metadata is not None:
            oprot.writeFieldBegin('footer_signing_key_metadata', TType.STRING, 9)
            oprot.writeBinary(self.footer_signing_key_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.schema is None:
            raise TProtocolException(message='Required field schema is unset!')
        if self.num_rows is None:
            raise TProtocolException(message='Required field num_rows is unset!')
        if self.row_groups is None:
            raise TProtocolException(message='Required field row_groups is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FileCryptoMetaData(object):
    """
    Crypto metadata for files with encrypted footer *

    Attributes:
     - encryption_algorithm: Encryption algorithm. This field is only used for files
    with encrypted footer. Files with plaintext footer store algorithm id
    inside footer (FileMetaData structure).
     - key_metadata: Retrieval metadata of key used for encryption of footer,
    and (possibly) columns *

    """


    def __init__(self, encryption_algorithm=None, key_metadata=None,):
        self.encryption_algorithm = encryption_algorithm
        self.key_metadata = key_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.encryption_algorithm = EncryptionAlgorithm()
                    self.encryption_algorithm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key_metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FileCryptoMetaData')
        if self.encryption_algorithm is not None:
            oprot.writeFieldBegin('encryption_algorithm', TType.STRUCT, 1)
            self.encryption_algorithm.write(oprot)
            oprot.writeFieldEnd()
        if self.key_metadata is not None:
            oprot.writeFieldBegin('key_metadata', TType.STRING, 2)
            oprot.writeBinary(self.key_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.encryption_algorithm is None:
            raise TProtocolException(message='Required field encryption_algorithm is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SizeStatistics)
SizeStatistics.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'unencoded_byte_array_data_bytes', None, None, ),  # 1
    (2, TType.LIST, 'repetition_level_histogram', (TType.I64, None, False), None, ),  # 2
    (3, TType.LIST, 'definition_level_histogram', (TType.I64, None, False), None, ),  # 3
)
all_structs.append(Statistics)
Statistics.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'max', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'min', 'BINARY', None, ),  # 2
    (3, TType.I64, 'null_count', None, None, ),  # 3
    (4, TType.I64, 'distinct_count', None, None, ),  # 4
    (5, TType.STRING, 'max_value', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'min_value', 'BINARY', None, ),  # 6
    (7, TType.BOOL, 'is_max_value_exact', None, None, ),  # 7
    (8, TType.BOOL, 'is_min_value_exact', None, None, ),  # 8
)
all_structs.append(StringType)
StringType.thrift_spec = (
)
all_structs.append(UUIDType)
UUIDType.thrift_spec = (
)
all_structs.append(MapType)
MapType.thrift_spec = (
)
all_structs.append(ListType)
ListType.thrift_spec = (
)
all_structs.append(EnumType)
EnumType.thrift_spec = (
)
all_structs.append(DateType)
DateType.thrift_spec = (
)
all_structs.append(Float16Type)
Float16Type.thrift_spec = (
)
all_structs.append(NullType)
NullType.thrift_spec = (
)
all_structs.append(DecimalType)
DecimalType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'scale', None, None, ),  # 1
    (2, TType.I32, 'precision', None, None, ),  # 2
)
all_structs.append(MilliSeconds)
MilliSeconds.thrift_spec = (
)
all_structs.append(MicroSeconds)
MicroSeconds.thrift_spec = (
)
all_structs.append(NanoSeconds)
NanoSeconds.thrift_spec = (
)
all_structs.append(TimeUnit)
TimeUnit.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'MILLIS', [MilliSeconds, None], None, ),  # 1
    (2, TType.STRUCT, 'MICROS', [MicroSeconds, None], None, ),  # 2
    (3, TType.STRUCT, 'NANOS', [NanoSeconds, None], None, ),  # 3
)
all_structs.append(TimestampType)
TimestampType.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isAdjustedToUTC', None, None, ),  # 1
    (2, TType.STRUCT, 'unit', [TimeUnit, None], None, ),  # 2
)
all_structs.append(TimeType)
TimeType.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isAdjustedToUTC', None, None, ),  # 1
    (2, TType.STRUCT, 'unit', [TimeUnit, None], None, ),  # 2
)
all_structs.append(IntType)
IntType.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'bitWidth', None, None, ),  # 1
    (2, TType.BOOL, 'isSigned', None, None, ),  # 2
)
all_structs.append(JsonType)
JsonType.thrift_spec = (
)
all_structs.append(BsonType)
BsonType.thrift_spec = (
)
all_structs.append(LogicalType)
LogicalType.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'STRING', [StringType, None], None, ),  # 1
    (2, TType.STRUCT, 'MAP', [MapType, None], None, ),  # 2
    (3, TType.STRUCT, 'LIST', [ListType, None], None, ),  # 3
    (4, TType.STRUCT, 'ENUM', [EnumType, None], None, ),  # 4
    (5, TType.STRUCT, 'DECIMAL', [DecimalType, None], None, ),  # 5
    (6, TType.STRUCT, 'DATE', [DateType, None], None, ),  # 6
    (7, TType.STRUCT, 'TIME', [TimeType, None], None, ),  # 7
    (8, TType.STRUCT, 'TIMESTAMP', [TimestampType, None], None, ),  # 8
    None,  # 9
    (10, TType.STRUCT, 'INTEGER', [IntType, None], None, ),  # 10
    (11, TType.STRUCT, 'UNKNOWN', [NullType, None], None, ),  # 11
    (12, TType.STRUCT, 'JSON', [JsonType, None], None, ),  # 12
    (13, TType.STRUCT, 'BSON', [BsonType, None], None, ),  # 13
    (14, TType.STRUCT, 'UUID', [UUIDType, None], None, ),  # 14
    (15, TType.STRUCT, 'FLOAT16', [Float16Type, None], None, ),  # 15
)
all_structs.append(SchemaElement)
SchemaElement.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'type_length', None, None, ),  # 2
    (3, TType.I32, 'repetition_type', None, None, ),  # 3
    (4, TType.STRING, 'name', 'UTF8', None, ),  # 4
    (5, TType.I32, 'num_children', None, None, ),  # 5
    (6, TType.I32, 'converted_type', None, None, ),  # 6
    (7, TType.I32, 'scale', None, None, ),  # 7
    (8, TType.I32, 'precision', None, None, ),  # 8
    (9, TType.I32, 'field_id', None, None, ),  # 9
    (10, TType.STRUCT, 'logicalType', [LogicalType, None], None, ),  # 10
)
all_structs.append(DataPageHeader)
DataPageHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_values', None, None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
    (3, TType.I32, 'definition_level_encoding', None, None, ),  # 3
    (4, TType.I32, 'repetition_level_encoding', None, None, ),  # 4
    (5, TType.STRUCT, 'statistics', [Statistics, None], None, ),  # 5
)
all_structs.append(IndexPageHeader)
IndexPageHeader.thrift_spec = (
)
all_structs.append(DictionaryPageHeader)
DictionaryPageHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_values', None, None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
    (3, TType.BOOL, 'is_sorted', None, None, ),  # 3
)
all_structs.append(DataPageHeaderV2)
DataPageHeaderV2.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_values', None, None, ),  # 1
    (2, TType.I32, 'num_nulls', None, None, ),  # 2
    (3, TType.I32, 'num_rows', None, None, ),  # 3
    (4, TType.I32, 'encoding', None, None, ),  # 4
    (5, TType.I32, 'definition_levels_byte_length', None, None, ),  # 5
    (6, TType.I32, 'repetition_levels_byte_length', None, None, ),  # 6
    (7, TType.BOOL, 'is_compressed', None, True, ),  # 7
    (8, TType.STRUCT, 'statistics', [Statistics, None], None, ),  # 8
)
all_structs.append(SplitBlockAlgorithm)
SplitBlockAlgorithm.thrift_spec = (
)
all_structs.append(BloomFilterAlgorithm)
BloomFilterAlgorithm.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'BLOCK', [SplitBlockAlgorithm, None], None, ),  # 1
)
all_structs.append(XxHash)
XxHash.thrift_spec = (
)
all_structs.append(BloomFilterHash)
BloomFilterHash.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'XXHASH', [XxHash, None], None, ),  # 1
)
all_structs.append(Uncompressed)
Uncompressed.thrift_spec = (
)
all_structs.append(BloomFilterCompression)
BloomFilterCompression.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'UNCOMPRESSED', [Uncompressed, None], None, ),  # 1
)
all_structs.append(BloomFilterHeader)
BloomFilterHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'numBytes', None, None, ),  # 1
    (2, TType.STRUCT, 'algorithm', [BloomFilterAlgorithm, None], None, ),  # 2
    (3, TType.STRUCT, 'hash', [BloomFilterHash, None], None, ),  # 3
    (4, TType.STRUCT, 'compression', [BloomFilterCompression, None], None, ),  # 4
)
all_structs.append(PageHeader)
PageHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'uncompressed_page_size', None, None, ),  # 2
    (3, TType.I32, 'compressed_page_size', None, None, ),  # 3
    (4, TType.I32, 'crc', None, None, ),  # 4
    (5, TType.STRUCT, 'data_page_header', [DataPageHeader, None], None, ),  # 5
    (6, TType.STRUCT, 'index_page_header', [IndexPageHeader, None], None, ),  # 6
    (7, TType.STRUCT, 'dictionary_page_header', [DictionaryPageHeader, None], None, ),  # 7
    (8, TType.STRUCT, 'data_page_header_v2', [DataPageHeaderV2, None], None, ),  # 8
)
all_structs.append(KeyValue)
KeyValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)
all_structs.append(SortingColumn)
SortingColumn.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'column_idx', None, None, ),  # 1
    (2, TType.BOOL, 'descending', None, None, ),  # 2
    (3, TType.BOOL, 'nulls_first', None, None, ),  # 3
)
all_structs.append(PageEncodingStats)
PageEncodingStats.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'page_type', None, None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
)
all_structs.append(ColumnMetaData)
ColumnMetaData.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'path_in_schema', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I32, 'codec', None, None, ),  # 4
    (5, TType.I64, 'num_values', None, None, ),  # 5
    (6, TType.I64, 'total_uncompressed_size', None, None, ),  # 6
    (7, TType.I64, 'total_compressed_size', None, None, ),  # 7
    (8, TType.LIST, 'key_value_metadata', (TType.STRUCT, [KeyValue, None], False), None, ),  # 8
    (9, TType.I64, 'data_page_offset', None, None, ),  # 9
    (10, TType.I64, 'index_page_offset', None, None, ),  # 10
    (11, TType.I64, 'dictionary_page_offset', None, None, ),  # 11
    (12, TType.STRUCT, 'statistics', [Statistics, None], None, ),  # 12
    (13, TType.LIST, 'encoding_stats', (TType.STRUCT, [PageEncodingStats, None], False), None, ),  # 13
    (14, TType.I64, 'bloom_filter_offset', None, None, ),  # 14
    (15, TType.I32, 'bloom_filter_length', None, None, ),  # 15
    (16, TType.STRUCT, 'size_statistics', [SizeStatistics, None], None, ),  # 16
)
all_structs.append(EncryptionWithFooterKey)
EncryptionWithFooterKey.thrift_spec = (
)
all_structs.append(EncryptionWithColumnKey)
EncryptionWithColumnKey.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'path_in_schema', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'key_metadata', 'BINARY', None, ),  # 2
)
all_structs.append(ColumnCryptoMetaData)
ColumnCryptoMetaData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ENCRYPTION_WITH_FOOTER_KEY', [EncryptionWithFooterKey, None], None, ),  # 1
    (2, TType.STRUCT, 'ENCRYPTION_WITH_COLUMN_KEY', [EncryptionWithColumnKey, None], None, ),  # 2
)
all_structs.append(ColumnChunk)
ColumnChunk.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_path', 'UTF8', None, ),  # 1
    (2, TType.I64, 'file_offset', None, None, ),  # 2
    (3, TType.STRUCT, 'meta_data', [ColumnMetaData, None], None, ),  # 3
    (4, TType.I64, 'offset_index_offset', None, None, ),  # 4
    (5, TType.I32, 'offset_index_length', None, None, ),  # 5
    (6, TType.I64, 'column_index_offset', None, None, ),  # 6
    (7, TType.I32, 'column_index_length', None, None, ),  # 7
    (8, TType.STRUCT, 'crypto_metadata', [ColumnCryptoMetaData, None], None, ),  # 8
    (9, TType.STRING, 'encrypted_column_metadata', 'BINARY', None, ),  # 9
)
all_structs.append(RowGroup)
RowGroup.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [ColumnChunk, None], False), None, ),  # 1
    (2, TType.I64, 'total_byte_size', None, None, ),  # 2
    (3, TType.I64, 'num_rows', None, None, ),  # 3
    (4, TType.LIST, 'sorting_columns', (TType.STRUCT, [SortingColumn, None], False), None, ),  # 4
    (5, TType.I64, 'file_offset', None, None, ),  # 5
    (6, TType.I64, 'total_compressed_size', None, None, ),  # 6
    (7, TType.I16, 'ordinal', None, None, ),  # 7
)
all_structs.append(TypeDefinedOrder)
TypeDefinedOrder.thrift_spec = (
)
all_structs.append(ColumnOrder)
ColumnOrder.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'TYPE_ORDER', [TypeDefinedOrder, None], None, ),  # 1
)
all_structs.append(PageLocation)
PageLocation.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'offset', None, None, ),  # 1
    (2, TType.I32, 'compressed_page_size', None, None, ),  # 2
    (3, TType.I64, 'first_row_index', None, None, ),  # 3
)
all_structs.append(OffsetIndex)
OffsetIndex.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'page_locations', (TType.STRUCT, [PageLocation, None], False), None, ),  # 1
    (2, TType.LIST, 'unencoded_byte_array_data_bytes', (TType.I64, None, False), None, ),  # 2
)
all_structs.append(ColumnIndex)
ColumnIndex.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'null_pages', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'min_values', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'max_values', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I32, 'boundary_order', None, None, ),  # 4
    (5, TType.LIST, 'null_counts', (TType.I64, None, False), None, ),  # 5
    (6, TType.LIST, 'repetition_level_histograms', (TType.I64, None, False), None, ),  # 6
    (7, TType.LIST, 'definition_level_histograms', (TType.I64, None, False), None, ),  # 7
)
all_structs.append(AesGcmV1)
AesGcmV1.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'aad_prefix', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'aad_file_unique', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'supply_aad_prefix', None, None, ),  # 3
)
all_structs.append(AesGcmCtrV1)
AesGcmCtrV1.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'aad_prefix', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'aad_file_unique', 'BINARY', None, ),  # 2
    (3, TType.BOOL, 'supply_aad_prefix', None, None, ),  # 3
)
all_structs.append(EncryptionAlgorithm)
EncryptionAlgorithm.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'AES_GCM_V1', [AesGcmV1, None], None, ),  # 1
    (2, TType.STRUCT, 'AES_GCM_CTR_V1', [AesGcmCtrV1, None], None, ),  # 2
)
all_structs.append(FileMetaData)
FileMetaData.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'version', None, None, ),  # 1
    (2, TType.LIST, 'schema', (TType.STRUCT, [SchemaElement, None], False), None, ),  # 2
    (3, TType.I64, 'num_rows', None, None, ),  # 3
    (4, TType.LIST, 'row_groups', (TType.STRUCT, [RowGroup, None], False), None, ),  # 4
    (5, TType.LIST, 'key_value_metadata', (TType.STRUCT, [KeyValue, None], False), None, ),  # 5
    (6, TType.STRING, 'created_by', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'column_orders', (TType.STRUCT, [ColumnOrder, None], False), None, ),  # 7
    (8, TType.STRUCT, 'encryption_algorithm', [EncryptionAlgorithm, None], None, ),  # 8
    (9, TType.STRING, 'footer_signing_key_metadata', 'BINARY', None, ),  # 9
)
all_structs.append(FileCryptoMetaData)
FileCryptoMetaData.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'encryption_algorithm', [EncryptionAlgorithm, None], None, ),  # 1
    (2, TType.STRING, 'key_metadata', 'BINARY', None, ),  # 2
)
fix_spec(all_structs)
del all_structs
